# 1. 引入 vuetify
`不要用 vue3 项目会报错`

#### 使用 npm 引入流程
1.  vue create a33demo
2.  cd a33demo
3.  vue add vuetify

# 2. 关闭 ESLint 配置
```js
// 配置方式 vue.config.js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: [
    'vuetify'
  ],
})
module.exports = {
  lintOnSave:false
}
```

# 3. 项目文件命名方式
- 单端名字开头大写
- 多段名字全小写，中间用 '-' 链接

# 4. vue-router 路由配置
- 报错：(vue 和 vue-router 版本不匹配原因)
> export 'default' (imported as 'Router') was not found in 'vue-router' (possible exports: NavigationFailureType, RouterLink, RouterView, START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, loadRouteLocation, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey)

[参考博客](https://blog.csdn.net/qq_52185114/article/details/119360397)

### 这个代码是用vue2和vue3是没有什么问题的，不过我们现在已经是vue4了，很多东西都有所改变了。

# 4. Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client
> D:\front-end\a33\server\node_modules\mysql\lib\protocol\Parser.js:437
      throw err; // Rethrow non-MySQL errors
      ^

Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client
    at new NodeError (node:internal/errors:387:5)
    at ServerResponse.setHeader (node:_http_outgoing:644:11)
    at ServerResponse.header (D:\front-end\a33\server\node_modules\express\lib\response.js:794:10)
    at ServerResponse.json (D:\front-end\a33\server\node_modules\express\lib\response.js:275:10)
    at Query.<anonymous> (D:\front-end\a33\server\api\sqlHandle.js:34:17)
    at Query.<anonymous> (D:\front-end\a33\server\node_modules\mysql\lib\Connection.js:526:10)
    at Query._callback (D:\front-end\a33\server\node_modules\mysql\lib\Connection.js:488:16)
ules\mysql\lib\protocol\sequences\Sequence.js:83:24)    at Query._handleFinalResultPacket (D:\front-end\a33\server\node_modules\mysql\lib\protocol\sequences\Query.js:149:8)    at Query.EofPacket (D:\front-end\a33\server\node_modules\mysql\lib\protocol\sequences\Query.js:133:8) {  code: 'ERR_HTTP_HEADERS_SENT'
}

[https://blog.csdn.net/weixin_45822938/article/details/123240563]

- 该问题是由于服务端重复响应造成的
```js
// 问题：
db.query(sqlStr,userinfo.username,(err, result) => {
        if (err) {
            res.send({
                status:1,
                message:err.message
            })
        }
        if(result.length>0){
            res.send({
                status:1,
                msg:'用户名被占用'
            })
        }
        // 用户名可以使用
        res.send("ok")
    })

// 解决
db.query(sqlStr,userinfo.username,(err, result) => {
        if (err) {
            return res.send({
                status:1,
                message:err.message
            })
        }
        if(result.length>0){
            return res.send({
                status:1,
                msg:'用户名被占用'
            })
        }
        // 用户名可以使用
        res.send("ok")
    })
```

# 5. 前端获取自己的端口号
```js
// 获取自己的端口号
window.location.port
// 获取自己的href
window.location.href
```

# 6. 无法获取axios 获取到的 res 结果
```js
// 有问题
get(way){
    let result;
    let PORT = window.location.port;
    axios.get(`http://localhost:${PORT}${way}`).then((res)=>{
      // console.log(res);  
      result = JSON.stringify(res.data);
    }).catch(err=>{
      console.log(err);
    })
    console.log(result);
    return result;
  },

result 的值为 undefined

// 解决方法：
// 使用 async await   async 声明发放为异步方法， await 等待异步操作执行完毕
async get(way){
      let result;
      let PORT = window.location.port;
      await axios.get(`http://localhost:${PORT}${way}`).then((res)=>{
        // console.log(res);  
        result = JSON.stringify(res.data);
      }).catch(err=>{
        console.log(err);
      })
      console.log(result);
      return result;
    },
// 问题解决
```

# 6. 获取不到前端 post 过来的 数据
```js
PS D:\front-end\a33\server> node index.js
Server listening at port 3000
Connected!!!
undefined
{}
// 原始问题
app.post('/insertdata',(req, res)=>{
    console.log(req.body);
    // console.log(res);
})

// 解决方法 引入 body-parser 插件
// 导入 app.js
var bodyParser = require('body-parser');
app.use(bodyParser());

//这样就可以使用 req.body 来获取 post 传递来的值了
app.post('/', (req, res) => {
  console.log(req.body);
  res.send('完成');
});

```

# 7. 使用post 发送数据给 后端
```js
    async post(way,data){
      let PORT = window.location.port;
      await axios.post(`http://localhost:${PORT}${way}`,
        data
      ).then((res)=>{
        console.log(res);
      }).catch(err=>{
        console.log(err);
      })
    },
```

# 8.
```js
// 报错：
body-parser deprecated undefined extended: provide extended option app.js:11:20
// 解决方法
您必须显式地为bodyParser.urlencoded()设置extended，因为the default value is going to change in the next major version of body-parser。
示例：
app.use(bodyParser.urlencoded({ extended: true }));

从express 4.16.0开始，您还可以执行以下操作：

app.use(express.urlencoded({ extended: true }))
```

```js
// 报错:
body-parser deprecated bodyParser: use individual json/urlencoded middlewares at server.js:4:10

// 解决方法；
将 app.use(bodyParser())
替换成：
app.use(bodyParser.urlencoded());

app.use(bodyParser.json());
```

# 9. ES6 设置函数默认值
```js
设置的默认值 的参数列表只能放在最后面
// async get(ip = 'localhost',way){
async get(way,ip = 'localhost'){ // 例如
      let result;
      console.log(ip);
      let PORT = window.location.port;
      await axios.get(`http://${ip}:${PORT}${way}`).then((res)=>{
        result = res.data;
      }).catch(err=>{
        console.log(err);
      })
      console.log(result);
      return result;
    },
```

# 10. 过滤器 和 拦截器的区别
- 拦截器： 
  - 对所有请求和响应进行拦截
- 过滤器
  - 根据特定条件进行过滤筛选符合条件的值

- AOP 面向切面编程
  - 关注点是模块化 (统一抽取，调高复用)
  - 将影响多个类的公共行为抽取，封装到一个可重用模块，实现代码复用和模块解耦合

  - ![过滤器(Filter)与拦截器(Interceptor)](https://www.jianshu.com/p/cf088baa9b04)

# 11. 序列化 和 反序列化
- 序列化:
  - 将对象 转换为 可传输字节序列过程
- 反序列化
  - 将字节序列 转换为 对象

## 使用场景：
  - 跨平台存储
  - 网络传输

# 12. 将异步函数封装并使用
```js
// axios.js 封装 文件
/**
     * get 方法 从服务端获取数据
     * @param {*} way 请求地址
     * @param {*} ip default = 'localhost'
     */
export async function get(way,ip = 'localhost'){
    let result;
    let PORT = window.location.port;
    await axios.get(`http://${ip}:${PORT}${way}`).then((res)=>{
      result = res.data;
    }).catch(err=>{
      console.log(err);
    })
    console.log(result);
    return result;
  }

// mycharts 调用 要使用异步调用
async mounted(){
        // 表格初始化
        var myChart = echarts.init(document.getElementById('box'));
        // 绘制图表
        myChart.setOption(this.option)
        console.log(get('/passenger_flow/findAll'));

        let get_res = await get(`/passenger_flow/findAll`);
        
        console.log(get_res);
        // console.log(get(`/passenger_flow/passenger/{shopid}/{date}`));
    }
```

# 13 将字符串 替换为 数字
```js
        /**
         * 获取 客流量数 格式
         * @param {*} data 需要处理的数据
         */
        personal_data_format(data){
            let filter_data = this.data_filter(data);
            let res = [];
            filter_data[0].forEach((value) => {
              // 这里
                res.push(parseInt(value.forecast));
            })
            return res;
        }
```

# 14 $nextTick()
![nextTick](https://vue3js.cn/global/nextTick.html)

- 定义: 在下次 DOM 更新循环结束之后执行延迟回调。
- 在修改数据之后立即使用这个方法，获取更新后的 DOM

## 同步 和 异步
### 概念
- 同步
  - 在主线程上排队执行的任务，只能在前一个任务完成后，才能执行下一个任务
- 异步:
  - 任务不进入主线程，
  - 而是，进入"任务队列"（task queue）的任务
  - 只有"任务队列"通知主线程，某个异步任务可以执行了
  - 该任务才会进入主线程执行

### 运行机制
1. 所有同步任务都在主线程上，形成一个执行栈(execution context stack)
2. 除了主线程，还有一个"任务队列"(task queue)。只要有任务结束就放一个事件到任务队列中
3. 一旦执行完了 执行栈 的所有同步任务后，系统就会读取"任务队列"里的有哪些事件，结束等待状态，进入执行栈，开始执行
4. 主线程，重复上面的机制

```js
// 实现很简单，完全是基于语言执行机制实现，
// 直接创建一个异步任务，
// 那么nextTick自然就达到在同步任务后执行的目的

// js 中 void 是用于获取 undefined 的原始值

const p = Promise.resolve()
export function nextTick(fn?: () => void): Promise<void> {
  return fn ? p.then(fn) : p
}
```

## 个人理解：
- 获取一个函数，然后进入异步队列，等待执行栈空了，再将获取到的值返回


# 15 proxy
![问题](./proxy%20%E9%97%AE%E9%A2%98.png)

### `原因：`
- 项目文件 vue.config.js
![](./proxy%20%E9%97%AE%E9%A2%98%E5%8E%9F%E5%A7%8B%E9%85%8D%E7%BD%AE.png)

- 问题解决前
![](./proxy%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%89%8D%E9%85%8D%E7%BD%AE.png)

- 问题解决后：
![](./proxy%20%E8%A7%A3%E5%86%B3%E5%90%8E.png)

## 出现问题原因:
```js
  ws: true,// 是否支持websocket
```

### webpack-dev-server 反向代理配置
```js
module.exports = {
    //...
    devServer: {
        proxy: [
            {
                context: ['/auth', '/api'],
                target: 'http://localhost:3000',
            },
        ],
    },
};
/**
 * 基本配置项
 *  1. proxy: devServer 代理配置
 *  2. /api:  表示需要代理的请求 url
 *  3. target: 反向代理地址
 *  4. pathRewrite: 请求地址重写，类似于 Nginx 的 Rewrite 功能
 * 
 * 其他配置参考
 *  1. logLevel: 日志打印级别 [debug, info, warn, error, silent], silent：不打印日志
 *  2. logProvider: 自定义日志打印中间件
 *  3. secure: 是否关闭 https 安全认证
 *  4. changeOrigin: 修改代理请求 host
 *  5. protocolRewrite: 协议重写， http 与 https 请求互转
 *  6. cookieDomainRewrite: 修改 cookieDomain 的值
 *  7. headers: 给所有请求添加 headers 配置
 *  8. proxyTimeout： 请求超时时间
 * 
 * 
 * 高级代理机制
 *  1. onError： 对请求状态码进行处理
    * function onError(err, req, res, target) {
          res.writeHead(500, {
              'Content-Type': 'text/plain',
          });
          res.end('Something went wrong. And we are reporting a custom error message.');
      }
 *
 *  2. onProxyRes: 对代理接口的 Response 处理， 这里常常用于获取 cookie、重定向
    function onProxyRes(proxyRes, req, res) {
          proxyRes.headers['x-added'] = 'foobar'; // 添加一个header
          delete proxyRes.headers['x-removed']; // 删除一个header
      }
 *
 *  3. onProxyReq 对于代理接口 request 处理，执行在请求前，常用来设置 cookie、header等操作
    function onProxyReq(proxyReq, req, res) {
        // add custom header to request
        proxyReq.setHeader('x-added', 'foobar');
        // or log the req
    }
 */
```

## **`webpack-dev-server`** 与 **`nginx`** 的对比

||wepack-dev-server|nginx|
|:-:|:-:|:-:|
 使用场景 | 本地开发 | 全场景 
 网络支持 |  https/http/http2/ws | https/http/http2/ws/ftp等 
 加载方式 | 编译代码后加载到内存，性能更好，可以结合webpack进行热更新，项目较大时会占据过多内存 | 读取硬盘中的内容，适合大项目
gzip支持 |  支持 | 支持 
线程  | 单线程 | 多线程  
正向代理 |  不支持 | 支持  
反向代理 |  支持 | 支持，功能更强大  
服务支持  | 单点支持 | 支持多服务，负载均衡  
上手难度 |  易 | 难  
总结  | 非常适合本地开发态，其中代码都是读取到内存中，性能更好，减少了每次更改后编译的时间，上手简单学习成本较低，在一些鉴权场景下不需要其他第三方插件就可以获取cookie等信息,对开发者更友好。但由于编译和代理绑定，每次修改配置的成本较大 | 十项全能，是一款非常优秀的服务器，功能非常强大，但配置也较为复杂，有一定的学习成本，本地联调需要借助浏览器插件才可以获取cookie等浏览器信息，配置文件维护涉及团队沟通成本


- [webpack-dev-server 从入门到实战](https://juejin.cn/post/7010571347705200671)

# 16 Grid 布局
[grid布局](https://www.jianshu.com/p/3762f214cd6f)


